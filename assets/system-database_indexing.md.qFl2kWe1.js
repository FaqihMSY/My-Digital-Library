import{_ as n,c as i,o as t,ae as e}from"./chunks/framework.BlRNOFgT.js";const k=JSON.parse('{"title":"Rangkuman Materi IF3140 - Sistem Basis Data: Indexing","description":"","frontmatter":{},"headers":[],"relativePath":"system-database/indexing.md","filePath":"system-database/indexing.md"}'),r={name:"system-database/indexing.md"};function s(l,a,o,u,d,g){return t(),i("div",null,[...a[0]||(a[0]=[e('<h1 id="rangkuman-materi-if3140-sistem-basis-data-indexing" tabindex="-1">Rangkuman Materi IF3140 - Sistem Basis Data: Indexing <a class="header-anchor" href="#rangkuman-materi-if3140-sistem-basis-data-indexing" aria-label="Permalink to &quot;Rangkuman Materi IF3140 - Sistem Basis Data: Indexing&quot;">​</a></h1><p><strong>Waktu Belajar: 10 menit untuk materi, 10 menit untuk contoh soal</strong></p><h2 id="_1-pengenalan-index" tabindex="-1">1. Pengenalan Index <a class="header-anchor" href="#_1-pengenalan-index" aria-label="Permalink to &quot;1. Pengenalan Index&quot;">​</a></h2><ul><li><strong>Index</strong> digunakan untuk mempercepat akses ke data yang diinginkan</li><li><strong>Contoh</strong>: katalog penulis di perpustakaan</li><li><strong>Search Key</strong>: atribut atau kumpulan atribut untuk mencari record di file</li><li><strong>Index file</strong>: berisi entri index berbentuk <code>search-key | pointer</code></li><li><strong>Jenis indeks dasar</strong>: <ul><li><strong>Ordered indices</strong>: kunci pencarian disimpan dalam urutan terurut</li><li><strong>Hash indices</strong>: kunci pencarian didistribusikan merata ke &quot;bucket&quot; menggunakan fungsi hash</li></ul></li></ul><h3 id="tabel-perbandingan" tabindex="-1">Tabel Perbandingan <a class="header-anchor" href="#tabel-perbandingan" aria-label="Permalink to &quot;Tabel Perbandingan&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Jenis Indeks</th><th>Karakteristik</th></tr></thead><tbody><tr><td>Ordered Indices</td><td>Kunci disimpan terurut</td></tr><tr><td>Hash Indices</td><td>Kunci didistribusikan ke bucket via hash</td></tr></tbody></table><h3 id="contoh-soal-latihan" tabindex="-1">Contoh Soal Latihan <a class="header-anchor" href="#contoh-soal-latihan" aria-label="Permalink to &quot;Contoh Soal Latihan&quot;">​</a></h3><ol><li><strong>Kasus</strong>: Sebuah perpustakaan ingin mencari buku berdasarkan nama penulis. Jenis indeks apa yang paling cocok dan mengapa? <ul><li><strong>Jawaban</strong>: Ordered indices, karena kunci (nama penulis) dapat disimpan terurut untuk pencarian cepat.</li></ul></li><li><strong>Kasus</strong>: Sistem database memiliki 1000 record dan ingin akses cepat berdasarkan ID unik. Apa yang perlu dibuat? <ul><li><strong>Jawaban</strong>: Index dengan search key pada ID, idealnya primary index untuk urutan sekuensial.</li></ul></li><li><strong>Kasus</strong>: Database memiliki atribut &quot;status&quot; (aktif/tidak aktif) untuk 5000 record. Bagaimana cara efisien mencari record &quot;aktif&quot;? <ul><li><strong>Jawaban</strong>: Gunakan hash index dengan fungsi hash pada nilai &quot;aktif&quot; untuk distribusi cepat.</li></ul></li></ol><h2 id="_2-fungsi-dan-evaluasi-index" tabindex="-1">2. Fungsi dan Evaluasi Index <a class="header-anchor" href="#_2-fungsi-dan-evaluasi-index" aria-label="Permalink to &quot;2. Fungsi dan Evaluasi Index&quot;">​</a></h2><ul><li><strong>Fungsi index</strong>: mendukung akses efisien ke data, mempermudah pencarian, pengurutan, operasi join, dll., tanpa memindai seluruh baris tabel</li><li><strong>Index file</strong>: biasanya jauh lebih kecil dari file asli</li><li><strong>Metrik evaluasi</strong>: <ul><li><strong>Access types</strong>: mendukung pencarian berdasarkan nilai atribut tertentu atau rentang nilai</li><li><strong>Access time</strong>: waktu akses data</li><li><strong>Insertion time</strong>: waktu menambahkan data</li><li><strong>Deletion time</strong>: waktu menghapus data</li><li><strong>Space overhead</strong>: ruang tambahan yang digunakan</li></ul></li></ul><h3 id="contoh-soal-latihan-1" tabindex="-1">Contoh Soal Latihan <a class="header-anchor" href="#contoh-soal-latihan-1" aria-label="Permalink to &quot;Contoh Soal Latihan&quot;">​</a></h3><ol><li><strong>Kasus</strong>: Database perlu mencari semua karyawan dengan gaji antara 5000-10000. Metrik evaluasi apa yang paling relevan? <ul><li><strong>Jawaban</strong>: Access types, karena mendukung pencarian berdasarkan rentang nilai.</li></ul></li><li><strong>Kasus</strong>: Setelah menambah 200 record baru, performa indeks menurun. Metrik apa yang perlu diperiksa? <ul><li><strong>Jawaban</strong>: Insertion time dan space overhead untuk mengevaluasi efisiensi.</li></ul></li><li><strong>Kasus</strong>: Sistem ingin menghapus 50 record lama. Apa yang harus diperhatikan? <ul><li><strong>Jawaban</strong>: Deletion time untuk memastikan proses cepat.</li></ul></li></ol><h2 id="_3-metode-index" tabindex="-1">3. Metode Index <a class="header-anchor" href="#_3-metode-index" aria-label="Permalink to &quot;3. Metode Index&quot;">​</a></h2><ul><li><strong>Metode yang dibahas</strong>: <ul><li><strong>Ordered indices</strong> (index-sequential file)</li><li><strong>B+-tree indices</strong></li><li><strong>Hash indices</strong></li><li><strong>Bitmap indices</strong></li></ul></li></ul><h3 id="tabel-perbandingan-1" tabindex="-1">Tabel Perbandingan <a class="header-anchor" href="#tabel-perbandingan-1" aria-label="Permalink to &quot;Tabel Perbandingan&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Metode</th><th>Kelebihan</th><th>Kekurangan</th></tr></thead><tbody><tr><td>Ordered Indices</td><td>Pencarian terurut</td><td>Performa turun saat file besar</td></tr><tr><td>B+-tree</td><td>Otomatis reorganisasi</td><td>Overhead penyisipan/hapusan</td></tr><tr><td>Hash Indices</td><td>Pencarian kesetaraan cepat</td><td>Kurang efisien untuk rentang</td></tr><tr><td>Bitmap Indices</td><td>Efisien untuk multi-atribut</td><td>Kurang efektif untuk satu atribut</td></tr></tbody></table><h3 id="contoh-soal-latihan-2" tabindex="-1">Contoh Soal Latihan <a class="header-anchor" href="#contoh-soal-latihan-2" aria-label="Permalink to &quot;Contoh Soal Latihan&quot;">​</a></h3><ol><li><strong>Kasus</strong>: Database memiliki 10.000 record dengan pencarian berdasarkan rentang nilai. Metode apa yang terbaik? <ul><li><strong>Jawaban</strong>: B+-tree, karena efisien untuk query rentang.</li></ul></li><li><strong>Kasus</strong>: Sistem perlu mencari data berdasarkan ID unik dengan distribusi merata. Apa yang digunakan? <ul><li><strong>Jawaban</strong>: Hash indices untuk akses cepat kesetaraan.</li></ul></li><li><strong>Kasus</strong>: Atribut &quot;jenis kelamin&quot; digunakan untuk filter data. Metode apa yang cocok? <ul><li><strong>Jawaban</strong>: Bitmap indices, karena atribut memiliki sedikit nilai berbeda.</li></ul></li></ol><h2 id="_4-ordered-indices" tabindex="-1">4. Ordered Indices <a class="header-anchor" href="#_4-ordered-indices" aria-label="Permalink to &quot;4. Ordered Indices&quot;">​</a></h2><ul><li><strong>Ciri</strong>: entri index disimpan terurut berdasarkan nilai kunci pencarian</li><li><strong>Primary index</strong>: kunci menentukan urutan sekuensial file (juga disebut clustering index) <ul><li>Hanya satu clustered index per tabel</li><li>Kunci biasanya primary key, tapi tidak selalu</li></ul></li><li><strong>Secondary index</strong>: kunci menentukan urutan berbeda dari file asli (non-clustering index)</li><li><strong>Index-sequential file</strong>: file sekuensial terurut dengan primary index</li><li><strong>Dense index</strong>: setiap kunci pencarian ada di record index (pencarian via binary search, kompleksitas log₂ n)</li><li><strong>Sparse index</strong>: hanya beberapa kunci ada di record index <ul><li>Efisien ruang dan pemeliharaan</li><li>Lebih lambat untuk pencarian, tapi baik dengan entri per blok</li></ul></li></ul><h3 id="tabel-perbandingan-2" tabindex="-1">Tabel Perbandingan <a class="header-anchor" href="#tabel-perbandingan-2" aria-label="Permalink to &quot;Tabel Perbandingan&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Jenis</th><th>Dense Index</th><th>Sparse Index</th></tr></thead><tbody><tr><td>Cakupan Kunci</td><td>Semua kunci ada</td><td>Hanya beberapa kunci</td></tr><tr><td>Kecepatan Pencarian</td><td>Cepat (binary search)</td><td>Lambat (sekuensial)</td></tr><tr><td>Ruang</td><td>Lebih besar</td><td>Lebih kecil</td></tr></tbody></table><h3 id="contoh-soal-latihan-3" tabindex="-1">Contoh Soal Latihan <a class="header-anchor" href="#contoh-soal-latihan-3" aria-label="Permalink to &quot;Contoh Soal Latihan&quot;">​</a></h3><ol><li><strong>Kasus</strong>: Tabel memiliki 1000 record terurut berdasarkan ID. Haruskah menggunakan dense atau sparse index? <ul><li><strong>Jawaban</strong>: Sparse index, untuk efisiensi ruang dengan record terurut.</li></ul></li><li><strong>Kasus</strong>: Sistem perlu indeks pada nama departemen yang tidak terurut. Apa jenisnya? <ul><li><strong>Jawaban</strong>: Secondary index, karena urutan berbeda dari file asli.</li></ul></li><li><strong>Kasus</strong>: Database hanya boleh punya satu indeks terurut. Apa itu? <ul><li><strong>Jawaban</strong>: Primary index (clustering index).</li></ul></li></ol><h2 id="_5-b-tree-index" tabindex="-1">5. B+-Tree Index <a class="header-anchor" href="#_5-b-tree-index" aria-label="Permalink to &quot;5. B+-Tree Index&quot;">​</a></h2><ul><li><strong>Kelebihan</strong>: reorganisasi otomatis dengan perubahan lokal saat penyisipan/hapusan</li><li><strong>Kekurangan</strong>: overhead penyisipan, hapusan, dan ruang</li><li><strong>Ciri</strong>: <ul><li>Semua jalur dari root ke leaf sama panjang</li><li>Node non-root memiliki antara ⌈n/2⌉ dan n anak</li><li>Leaf memiliki antara ⌈(n-1)/2⌉ dan n-1 nilai</li></ul></li><li><strong>Pencarian</strong>: tinggi pohon ≤ ⌈log⌈n/2⌉(K)⌉, efisien untuk query rentang</li><li><strong>Penanganan</strong>: penyisipan dan hapusan dengan split/merge</li></ul><h3 id="contoh-soal-latihan-4" tabindex="-1">Contoh Soal Latihan <a class="header-anchor" href="#contoh-soal-latihan-4" aria-label="Permalink to &quot;Contoh Soal Latihan&quot;">​</a></h3><ol><li><strong>Kasus</strong>: Database dengan 1 juta record menggunakan B+-tree (n=100). Berapa maksimum node yang diakses? <ul><li><strong>Jawaban</strong>: 4 node (log₅₀(1.000.000)).</li></ul></li><li><strong>Kasus</strong>: Setelah hapus data, leaf menjadi underfull. Apa yang terjadi? <ul><li><strong>Jawaban</strong>: Leaf akan merge dengan sibling.</li></ul></li><li><strong>Kasus</strong>: Tambah data baru menyebabkan overflow. Bagaimana solusinya? <ul><li><strong>Jawaban</strong>: Lakukan split pada node.</li></ul></li></ol><h2 id="_6-hash-index" tabindex="-1">6. Hash Index <a class="header-anchor" href="#_6-hash-index" aria-label="Permalink to &quot;6. Hash Index&quot;">​</a></h2><ul><li><strong>Ciri</strong>: gunakan fungsi hash h(ki) untuk memetakan kunci ke bucket</li><li><strong>Bucket</strong>: unit penyimpanan (biasanya satu blok) berisi kunci dan pointer</li><li><strong>Kelebihan</strong>: pencarian kesetaraan sangat cepat</li><li><strong>Kekurangan</strong>: tidak efisien untuk query rentang, bisa overflow (di-handle dengan chaining)</li><li><strong>Fungsi hash ideal</strong>: seragam dan acak untuk minimalkan overflow</li><li><strong>Jenis</strong>: <ul><li><strong>Static hashing</strong>: jumlah bucket tetap</li><li><strong>Dynamic hashing</strong>: bucket bisa ditambah</li></ul></li></ul><h3 id="contoh-soal-latihan-5" tabindex="-1">Contoh Soal Latihan <a class="header-anchor" href="#contoh-soal-latihan-5" aria-label="Permalink to &quot;Contoh Soal Latihan&quot;">​</a></h3><ol><li><strong>Kasus</strong>: Sistem ingin cari record berdasarkan ID unik. Metode apa yang cocok? <ul><li><strong>Jawaban</strong>: Hash index, untuk pencarian kesetaraan cepat.</li></ul></li><li><strong>Kasus</strong>: Hash menghasilkan overflow. Bagaimana menanganinya? <ul><li><strong>Jawaban</strong>: Gunakan overflow chaining dengan linked list.</li></ul></li><li><strong>Kasus</strong>: Data bertambah 50%, hashing statis tidak cukup. Solusinya? <ul><li><strong>Jawaban</strong>: Gunakan dynamic hashing untuk tambah bucket.</li></ul></li></ol><h2 id="_7-bitmap-indices" tabindex="-1">7. Bitmap Indices <a class="header-anchor" href="#_7-bitmap-indices" aria-label="Permalink to &quot;7. Bitmap Indices&quot;">​</a></h2><ul><li><strong>Ciri</strong>: dirancang untuk query multi-atribut dengan nilai atribut sedikit (misal: gender, status)</li><li><strong>Kegunaan</strong>: efisien untuk kombinasi atribut, kurang untuk satu atribut</li><li><strong>Operasi</strong>: gunakan AND, OR, NOT pada bitmap</li><li><strong>Contoh</strong>: query &quot;laki-laki dengan income L1&quot; pakai 10010 AND 10100 = 10000</li></ul><h3 id="contoh-soal-latihan-6" tabindex="-1">Contoh Soal Latihan <a class="header-anchor" href="#contoh-soal-latihan-6" aria-label="Permalink to &quot;Contoh Soal Latihan&quot;">​</a></h3><ol><li><strong>Kasus</strong>: Tabel memiliki atribut &quot;status&quot; (aktif/tidak) untuk 1000 record. Bagaimana cari &quot;aktif&quot;? <ul><li><strong>Jawaban</strong>: Gunakan bitmap index, operasikan bitmap &quot;aktif&quot;.</li></ul></li><li><strong>Kasus</strong>: Query gabungkan &quot;laki-laki&quot; dan &quot;income &gt;50000&quot;. Metode apa? <ul><li><strong>Jawaban</strong>: Bitmap indices dengan operasi AND.</li></ul></li><li><strong>Kasus</strong>: Hitung record &quot;perempuan&quot; dari bitmap 01001. Berapa? <ul><li><strong>Jawaban</strong>: 1 record (berdasarkan bit &quot;1&quot;).</li></ul></li></ol><h2 id="_8-definisi-index-di-sql" tabindex="-1">8. Definisi Index di SQL <a class="header-anchor" href="#_8-definisi-index-di-sql" aria-label="Permalink to &quot;8. Definisi Index di SQL&quot;">​</a></h2><ul><li><strong>Buat index</strong>: <code>create index &lt;nama&gt; on &lt;relasi&gt;(&lt;atribut&gt;)</code> (contoh: <code>create index b-index on branch(branch_name)</code>)</li><li><strong>Buat unique index</strong>: pakai <code>create unique index</code> untuk kunci kandidat</li><li><strong>Hapus index</strong>: <code>drop index &lt;nama&gt;</code></li><li><strong>Catatan</strong>: sebagian besar DBMS mendukung spesifikasi tipe dan clustering</li></ul><h3 id="contoh-soal-latihan-7" tabindex="-1">Contoh Soal Latihan <a class="header-anchor" href="#contoh-soal-latihan-7" aria-label="Permalink to &quot;Contoh Soal Latihan&quot;">​</a></h3><ol><li><strong>Kasus</strong>: Buat index untuk tabel &quot;student&quot; berdasarkan &quot;student_id&quot;. Tulis SQL-nya. <ul><li><strong>Jawaban</strong>: <code>create index s-index on student(student_id)</code>.</li></ul></li><li><strong>Kasus</strong>: Hapus index &quot;s-index&quot;. Tulis SQL-nya. <ul><li><strong>Jawaban</strong>: <code>drop index s-index</code>.</li></ul></li><li><strong>Kasus</strong>: Pastikan &quot;email&quot; unik di tabel &quot;user&quot;. Tulis SQL-nya. <ul><li><strong>Jawaban</strong>: <code>create unique index u-index on user(email)</code>.</li></ul></li></ol><h2 id="daftar-istilah-penting" tabindex="-1">Daftar Istilah Penting <a class="header-anchor" href="#daftar-istilah-penting" aria-label="Permalink to &quot;Daftar Istilah Penting&quot;">​</a></h2><ul><li><strong>Index</strong>: Struktur data untuk akses cepat ke data dalam database.</li><li><strong>Search Key</strong>: Atribut atau kumpulan atribut untuk mencari record.</li><li><strong>Primary Index</strong>: Indeks yang menentukan urutan sekuensial file (clustering index).</li><li><strong>Secondary Index</strong>: Indeks dengan urutan berbeda dari file asli (non-clustering index).</li><li><strong>Dense Index</strong>: Indeks di mana semua kunci pencarian ada di record.</li><li><strong>Sparse Index</strong>: Indeks dengan hanya beberapa kunci pencarian.</li><li><strong>B+-Tree</strong>: Pohon berbasis indeks dengan reorganisasi otomatis.</li><li><strong>Hash Index</strong>: Indeks yang menggunakan fungsi hash untuk distribusi data.</li><li><strong>Bitmap Indices</strong>: Indeks berbasis bitmap untuk query multi-atribut.</li><li><strong>Index-Sequential File</strong>: File terurut dengan primary index.</li></ul><h2 id="glossarium" tabindex="-1">Glossarium <a class="header-anchor" href="#glossarium" aria-label="Permalink to &quot;Glossarium&quot;">​</a></h2><ul><li><strong>ID</strong>: Identifikasi</li><li><strong>DBMS</strong>: Database Management System</li></ul>',44)])])}const b=n(r,[["render",s]]);export{k as __pageData,b as default};
