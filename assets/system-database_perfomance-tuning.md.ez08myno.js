import{_ as n,c as t,o as i,ae as r}from"./chunks/framework.BlRNOFgT.js";const h=JSON.parse('{"title":"Rangkuman Materi IF3140 - Performance Tuning","description":"","frontmatter":{},"headers":[],"relativePath":"system-database/perfomance-tuning.md","filePath":"system-database/perfomance-tuning.md"}'),s={name:"system-database/perfomance-tuning.md"};function e(o,a,l,u,g,d){return i(),t("div",null,[...a[0]||(a[0]=[r('<h1 id="rangkuman-materi-if3140-performance-tuning" tabindex="-1">Rangkuman Materi IF3140 - Performance Tuning <a class="header-anchor" href="#rangkuman-materi-if3140-performance-tuning" aria-label="Permalink to &quot;Rangkuman Materi IF3140 - Performance Tuning&quot;">​</a></h1><h2 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">​</a></h2><ul><li><strong>Definisi</strong>: Optimasi penggunaan sumber daya untuk meningkatkan throughput dan meminimalkan kontensi, memungkinkan beban kerja maksimum diproses.</li><li><strong>Tuning Levels</strong>: <ul><li><strong>Higher Level Database Design</strong>: Skema fisik (indeks, view materialisasi, splitting horizontal), query, transaksi, dan skema logis.</li><li><strong>Database System Parameters</strong>: Atur ukuran buffer untuk minimalkan I/O disk, atur interval checkpoint untuk batasi ukuran log.</li><li><strong>Hardware</strong>: Tambah disk untuk percepat I/O, tambah memori untuk tingkatkan hit buffer, ganti ke prosesor lebih cepat.</li></ul></li><li><strong>Fokus Tuning</strong>: Minimalkan I/O disk karena menjadi bottleneck utama.</li></ul><table tabindex="0"><thead><tr><th><strong>Parameter</strong></th><th><strong>HDD</strong></th><th><strong>SSD</strong></th></tr></thead><tbody><tr><td>Ukuran sektor/sel</td><td>512 B</td><td>2 B</td></tr><tr><td>Ukuran blok/halaman</td><td>4 KB</td><td>4 KB</td></tr><tr><td>Waktu baca blok acak</td><td>10 ms (5-20 ms akses, 0.1 ms transfer)</td><td>0.1 ms</td></tr><tr><td>Waktu akses blok di memori</td><td>~100 ns</td><td>~100 ns</td></tr></tbody></table><h3 id="contoh-soal-latihan" tabindex="-1">Contoh Soal Latihan <a class="header-anchor" href="#contoh-soal-latihan" aria-label="Permalink to &quot;Contoh Soal Latihan&quot;">​</a></h3><ol><li><strong>Kasus</strong>: Sebuah aplikasi web mengalami penundaan saat mengakses data. Apa yang bisa dilakukan untuk meningkatkan performa berdasarkan tuning level? <ul><li><strong>Jawaban</strong>: Periksa skema fisik (tambahkan indeks), optimalkan parameter sistem (tingkatkan ukuran buffer), atau tingkatkan hardware (tambahkan disk/memori).</li></ul></li><li><strong>Kasus</strong>: Database sering bottleneck di I/O disk. Bagaimana cara mengatasinya? <ul><li><strong>Jawaban</strong>: Gunakan SSD untuk waktu akses lebih cepat (0.1 ms vs 10 ms HDD) atau tambah memori untuk kurangi akses disk.</li></ul></li><li><strong>Kasus</strong>: Performa query menurun karena data besar. Apa solusi tuning yang tepat? <ul><li><strong>Jawaban</strong>: Tambahkan indeks pada kolom yang sering di-query atau gunakan splitting horizontal untuk bagi data.</li></ul></li></ol><h2 id="index-schema-tuning" tabindex="-1">Index + Schema Tuning <a class="header-anchor" href="#index-schema-tuning" aria-label="Permalink to &quot;Index + Schema Tuning&quot;">​</a></h2><ul><li><strong>Index</strong>: Struktur data untuk percepat akses data, menggunakan search key dan pointer.</li><li><strong>Index Tuning</strong>: Pilih tipe indeks (clustered/hash/tree, dinamis/statis, padat/sparse) berdasarkan kebutuhan.</li><li><strong>Schema Tuning</strong>: <ul><li><strong>Splitting</strong>: Pisah tabel secara horizontal (berdasarkan baris) atau vertikal (berdasarkan kolom).</li><li><strong>Denormalization</strong>: Tambah kolom redundan atau undo dekomposisi ke normal form lebih rendah.</li></ul></li></ul><table tabindex="0"><thead><tr><th><strong>Metode</strong></th><th><strong>Keuntungan</strong></th><th><strong>Kekurangan</strong></th></tr></thead><tbody><tr><td>Splitting Horizontal</td><td>Kurangi data yang diproses</td><td>Kompleksitas aplikasi</td></tr><tr><td>Denormalization</td><td>Percepat query</td><td>Risiko inkonsistensi data</td></tr></tbody></table><h3 id="contoh-soal-latihan-1" tabindex="-1">Contoh Soal Latihan <a class="header-anchor" href="#contoh-soal-latihan-1" aria-label="Permalink to &quot;Contoh Soal Latihan&quot;">​</a></h3><ol><li><strong>Kasus</strong>: Tabel besar menyebabkan query lambat. Apa yang bisa dilakukan dengan indeks? <ul><li><strong>Jawaban</strong>: Buat indeks clustered pada kolom yang sering di-sort atau indeks hash untuk pencarian cepat.</li></ul></li><li><strong>Kasus</strong>: Data duplikat meningkatkan performa query. Teknik schema apa yang digunakan? <ul><li><strong>Jawaban</strong>: Denormalization dengan tambah kolom redundan atau gabung tabel.</li></ul></li><li><strong>Kasus</strong>: Aplikasi butuh akses data regional saja. Solusi schema apa yang cocok? <ul><li><strong>Jawaban</strong>: Gunakan splitting horizontal untuk pisah data berdasarkan wilayah.</li></ul></li></ol><h2 id="query-tuning" tabindex="-1">Query Tuning <a class="header-anchor" href="#query-tuning" aria-label="Permalink to &quot;Query Tuning&quot;">​</a></h2><ul><li><strong>Query Plan</strong>: Gunakan EXPLAIN untuk lihat rencana eksekusi, ANALYZE untuk perbarui statistik.</li><li><strong>Set Orientation</strong>: Gabungkan query berulang dengan parameter berbeda untuk kurangi panggilan database.</li><li><strong>Tips</strong>: Tulis ulang subquery kompleks jadi join, gunakan hint optimizer jika perlu.</li></ul><h3 id="contoh-soal-latihan-2" tabindex="-1">Contoh Soal Latihan <a class="header-anchor" href="#contoh-soal-latihan-2" aria-label="Permalink to &quot;Contoh Soal Latihan&quot;">​</a></h3><ol><li><strong>Kasus</strong>: Query dengan subquery lambat. Bagaimana mengoptimalkannya? <ul><li><strong>Jawaban</strong>: Tulis ulang jadi join untuk percepat eksekusi.</li></ul></li><li><strong>Kasus</strong>: Statistik query sudah lama tidak diperbarui. Apa yang harus dilakukan? <ul><li><strong>Jawaban</strong>: Jalankan ANALYZE untuk perbarui statistik.</li></ul></li><li><strong>Kasus</strong>: Aplikasi sering panggil query serupa dengan nilai berbeda. Solusi apa yang tepat? <ul><li><strong>Jawaban</strong>: Gunakan set orientation dengan satu query untuk semua nilai.</li></ul></li></ol><h2 id="transaction-tuning" tabindex="-1">Transaction Tuning <a class="header-anchor" href="#transaction-tuning" aria-label="Permalink to &quot;Transaction Tuning&quot;">​</a></h2><ul><li><strong>Masalah Long Transaction</strong>: Sebabkan kontensi lock dan panjang waktu pemulihan.</li><li><strong>Solusi</strong>: <ul><li>Gunakan multi-version concurrency control (e.g., snapshot Oracle).</li><li>Gunakan cursor-stability untuk transaksi baca panjang.</li><li>Bagi transaksi besar jadi mini-batch untuk batasi update.</li></ul></li></ul><h3 id="contoh-soal-latihan-3" tabindex="-1">Contoh Soal Latihan <a class="header-anchor" href="#contoh-soal-latihan-3" aria-label="Permalink to &quot;Contoh Soal Latihan&quot;">​</a></h3><ol><li><strong>Kasus</strong>: Transaksi baca besar bentrok dengan update. Apa solusi terbaik? <ul><li><strong>Jawaban</strong>: Gunakan multi-version concurrency control.</li></ul></li><li><strong>Kasus</strong>: Transaksi update memenuhi log. Bagaimana mengatasinya? <ul><li><strong>Jawaban</strong>: Pisah jadi mini-batch untuk kurangi beban log.</li></ul></li><li><strong>Kasus</strong>: Perlu hasil transaksi baca mendekati real-time. Teknik apa yang digunakan? <ul><li><strong>Jawaban</strong>: Gunakan cursor-stability meskipun hasilnya kira-kira.</li></ul></li></ol><h2 id="hardware-tuning" tabindex="-1">Hardware Tuning <a class="header-anchor" href="#hardware-tuning" aria-label="Permalink to &quot;Hardware Tuning&quot;">​</a></h2><ul><li><strong>Strategi</strong>: Tambah disk untuk percepat I/O, tingkatkan memori untuk kurangi akses disk.</li><li><strong>Five-Minute Rule</strong>: Data diakses setiap 400 detik atau kurang layak disimpan di memori (berdasarkan harga 1987).</li><li><strong>One-Minute Rule</strong>: Data akses berurutan setiap 1 menit layak di memori.</li><li><strong>RAID</strong>: <ul><li><strong>RAID 0</strong>: Striping untuk percepat baca, tanpa toleransi fault.</li><li><strong>RAID 1</strong>: Mirroring untuk toleransi fault, butuh disk lebih.</li><li><strong>RAID 5</strong>: Parity untuk toleransi 1 kegagalan, efisien untuk baca banyak.</li><li><strong>RAID 10</strong>: Kombinasi striping dan mirroring, cepat dan toleran fault.</li></ul></li></ul><table tabindex="0"><thead><tr><th><strong>RAID Level</strong></th><th><strong>I/O Baca</strong></th><th><strong>I/O Tulis</strong></th><th><strong>Toleransi Fault</strong></th></tr></thead><tbody><tr><td>RAID 0</td><td>Cepat</td><td>Cepat</td><td>Tidak ada</td></tr><tr><td>RAID 1</td><td>Cepat</td><td>Sedang (2w)</td><td>Ada (mirroring)</td></tr><tr><td>RAID 5</td><td>Cepat</td><td>Lambat (4w)</td><td>Ada (1 kegagalan)</td></tr><tr><td>RAID 10</td><td>Cepat</td><td>Sedang (2w)</td><td>Ada (mirroring)</td></tr></tbody></table><h3 id="contoh-soal-latihan-4" tabindex="-1">Contoh Soal Latihan <a class="header-anchor" href="#contoh-soal-latihan-4" aria-label="Permalink to &quot;Contoh Soal Latihan&quot;">​</a></h3><ol><li><strong>Kasus</strong>: Sistem butuh kecepatan tinggi dan toleransi fault. RAID apa yang dipilih? <ul><li><strong>Jawaban</strong>: RAID 10 untuk kombinasi striping dan mirroring.</li></ul></li><li><strong>Kasus</strong>: Banyak operasi tulis, tapi anggaran terbatas. RAID apa yang cocok? <ul><li><strong>Jawaban</strong>: RAID 5 karena efisien dengan parity, meskipun tulis lambat.</li></ul></li><li><strong>Kasus</strong>: Data diakses setiap 300 detik. Apakah layak di memori? <ul><li><strong>Jawaban</strong>: Ya, berdasarkan five-minute rule (400 detik).</li></ul></li></ol><h2 id="performance-benchmark" tabindex="-1">Performance Benchmark <a class="header-anchor" href="#performance-benchmark" aria-label="Permalink to &quot;Performance Benchmark&quot;">​</a></h2><ul><li><strong>Definisi</strong>: Kumpulan tugas untuk ukur performa sistem database.</li><li><strong>Metrik</strong>: Throughput (transaksi/detik), response time, availability.</li><li><strong>TPC Benchmark</strong>: <ul><li><strong>TPC-C</strong>: Standar OLTP untuk sistem inventori.</li><li><strong>TPC-H</strong>: Ad hoc query dengan fokus agregasi.</li><li><strong>TPC-R</strong>: Laporan dengan view dan indeks bebas.</li></ul></li><li><strong>Rumus Throughput Rata-rata</strong>: Gunakan harmonic mean dari tps tiap transaksi.</li></ul><h3 id="contoh-soal-latihan-5" tabindex="-1">Contoh Soal Latihan <a class="header-anchor" href="#contoh-soal-latihan-5" aria-label="Permalink to &quot;Contoh Soal Latihan&quot;">​</a></h3><ol><li><strong>Kasus</strong>: Sistem punya throughput 99 tps (A) dan 1 tps (B) dengan campuran sama. Hitung throughput rata-rata. <ul><li><strong>Jawaban</strong>: Harmonic mean = 2 / (1/99 + 1/1) ≈ 1.98 tps.</li></ul></li><li><strong>Kasus</strong>: Perlu benchmark untuk query ad hoc. Gunakan yang mana? <ul><li><strong>Jawaban</strong>: TPC-H karena fokus pada query yang tidak diketahui sebelumnya.</li></ul></li><li><strong>Kasus</strong>: Sistem inventori butuh benchmark. Pilih yang tepat. <ul><li><strong>Jawaban</strong>: TPC-C sebagai standar OLTP.</li></ul></li></ol><h2 id="daftar-istilah-penting" tabindex="-1">Daftar Istilah Penting <a class="header-anchor" href="#daftar-istilah-penting" aria-label="Permalink to &quot;Daftar Istilah Penting&quot;">​</a></h2><ul><li><strong>Throughput</strong>: Jumlah transaksi yang diproses per detik.</li><li><strong>Contention</strong>: Persaingan sumber daya yang menyebabkan penundaan.</li><li><strong>Workload</strong>: Kumpulan query dan update yang menjadi fokus tuning.</li><li><strong>Index</strong>: Struktur data untuk percepat pencarian data.</li><li><strong>Denormalization</strong>: Proses tambah redundansi untuk tingkatkan performa.</li><li><strong>RAID</strong>: Teknik organisasi disk untuk kapasitas, kecepatan, dan reliabilitas.</li><li><strong>Benchmark</strong>: Uji performa sistem dengan serangkaian tugas.</li></ul><h2 id="glossarium" tabindex="-1">Glossarium <a class="header-anchor" href="#glossarium" aria-label="Permalink to &quot;Glossarium&quot;">​</a></h2><ul><li><strong>ER</strong>: Entity-Relationship (desain basis data).</li><li><strong>BCNF</strong>: Boyce-Codd Normal Form (tingkat normalisasi).</li><li><strong>OLTP</strong>: Online Transaction Processing (proses transaksi online).</li><li><strong>OLAP</strong>: Online Analytical Processing (analisis data online).</li><li><strong>TPC</strong>: Transaction Processing Council (organisasi benchmark).</li></ul>',32)])])}const m=n(s,[["render",e]]);export{h as __pageData,m as default};
