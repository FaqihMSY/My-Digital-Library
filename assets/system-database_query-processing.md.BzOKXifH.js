import{_ as i,c as t,o as n,ae as e}from"./chunks/framework.BlRNOFgT.js";const k=JSON.parse('{"title":"IF3140 – Sistem Basis Data: Query Processing","description":"","frontmatter":{},"headers":[],"relativePath":"system-database/query-processing.md","filePath":"system-database/query-processing.md"}'),s={name:"system-database/query-processing.md"};function r(o,a,l,u,d,b){return n(),t("div",null,[...a[0]||(a[0]=[e('<h1 id="if3140-–-sistem-basis-data-query-processing" tabindex="-1">IF3140 – Sistem Basis Data: Query Processing <a class="header-anchor" href="#if3140-–-sistem-basis-data-query-processing" aria-label="Permalink to &quot;IF3140 – Sistem Basis Data: Query Processing&quot;">​</a></h1><h2 id="basic-steps-in-query-processing" tabindex="-1">Basic Steps in Query Processing <a class="header-anchor" href="#basic-steps-in-query-processing" aria-label="Permalink to &quot;Basic Steps in Query Processing&quot;">​</a></h2><ul><li><strong>Parsing and translation</strong><ul><li>Terjemahkan query ke bentuk internal, lalu ke relational algebra</li><li>Periksa sintaks dan verifikasi relasi</li></ul></li><li><strong>Optimization</strong><ul><li>Pilih rencana evaluasi dengan biaya terendah berdasarkan statistik</li><li>Gunakan berbagai algoritma untuk operasi relational algebra</li></ul></li><li><strong>Evaluation</strong><ul><li>Mesin eksekusi menjalankan rencana evaluasi dan kembalikan hasil</li></ul></li></ul><h3 id="contoh-soal-latihan" tabindex="-1">Contoh Soal Latihan <a class="header-anchor" href="#contoh-soal-latihan" aria-label="Permalink to &quot;Contoh Soal Latihan&quot;">​</a></h3><ol><li><strong>Studi Kasus</strong>: Diberikan query <code>σ_salary&lt;75000(π_salary(instructor))</code>, jelaskan langkah optimasi yang bisa dilakukan.<br><strong>Jawaban</strong>: Ubah ke <code>π_salary(σ_salary&lt;75000(instructor))</code> dan gunakan indeks pada salary untuk efisiensi.</li><li><strong>Studi Kasus</strong>: Jika sebuah query dieksekusi tanpa optimasi, apa yang terjadi pada performa?<br><strong>Jawaban</strong>: Performa menurun karena setiap kombinasi tuple diuji, meningkatkan biaya disk I/O.</li><li><strong>Studi Kasus</strong>: Bagaimana cara memilih rencana evaluasi terbaik?<br><strong>Jawaban</strong>: Berdasarkan estimasi biaya menggunakan statistik seperti jumlah tuple dan ukuran blok.</li></ol><h2 id="measures-of-query-cost" tabindex="-1">Measures of Query Cost <a class="header-anchor" href="#measures-of-query-cost" aria-label="Permalink to &quot;Measures of Query Cost&quot;">​</a></h2><ul><li><strong>Biaya</strong> diukur sebagai total waktu untuk menjawab query</li><li><strong>Faktor biaya</strong> meliputi akses disk, CPU, dan komunikasi jaringan</li><li><strong>Estimasi biaya</strong> didominasi oleh akses disk <ul><li>Jumlah seek × biaya seek rata-rata</li><li>Jumlah blok dibaca × biaya baca blok rata-rata</li><li>Jumlah blok ditulis × biaya tulis blok rata-rata</li><li>Biaya tulis lebih besar karena data dibaca ulang untuk verifikasi</li></ul></li><li><strong>Sederhananya</strong>, gunakan jumlah transfer blok dan seek <ul><li>Rumus: <code>b * tT + S * tS</code> (tT = waktu transfer blok, tS = waktu seek)</li></ul></li><li><strong>ABAikan</strong> biaya CPU dan tulis output ke disk</li><li><strong>Algoritma</strong> bisa kurangi I/O disk dengan buffer tambahan <ul><li>Jumlah memori bergantung pada query lain dan OS, hanya diketahui saat eksekusi</li><li>Gunakan estimasi terburuk dengan memori minimum</li><li>Data di buffer bisa hindari I/O, tapi sulit diestimasikan</li></ul></li></ul><h3 id="contoh-soal-latihan-1" tabindex="-1">Contoh Soal Latihan <a class="header-anchor" href="#contoh-soal-latihan-1" aria-label="Permalink to &quot;Contoh Soal Latihan&quot;">​</a></h3><ol><li><strong>Studi Kasus</strong>: Jika sebuah query membutuhkan 100 blok dan 5 seek dengan tT = 1ms dan tS = 10ms, hitung biayanya.<br><strong>Jawaban</strong>: <code>100 * 1 + 5 * 10 = 150ms</code>.</li><li><strong>Studi Kasus</strong>: Mengapa biaya tulis blok lebih besar daripada baca?<br><strong>Jawaban</strong>: Karena data dibaca ulang untuk memastikan tulis berhasil.</li><li><strong>Studi Kasus</strong>: Bagaimana buffer tambahan memengaruhi biaya query?<br><strong>Jawaban</strong>: Mengurangi I/O disk jika data sudah di buffer, tapi estimasi sulit.</li></ol><h2 id="selection-operation" tabindex="-1">Selection Operation <a class="header-anchor" href="#selection-operation" aria-label="Permalink to &quot;Selection Operation&quot;">​</a></h2><ul><li><strong>File scan (A1 - linear search)</strong><ul><li>Pindai setiap blok file dan uji semua record</li><li>Biaya: <code>br</code> blok transfer + 1 seek (br = jumlah blok relasi r)</li><li>Jika seleksi pada atribut kunci, hentikan saat record ditemukan: biaya ~ <code>br/2</code> + 1 seek</li></ul></li><li><strong>Tanpa ketergantungan</strong> pada kondisi seleksi, urutan record, atau indeks</li><li><strong>Catatan</strong>: Pencarian biner tidak efektif kecuali ada indeks</li></ul><h3 id="tabel-perbandingan" tabindex="-1">Tabel Perbandingan <a class="header-anchor" href="#tabel-perbandingan" aria-label="Permalink to &quot;Tabel Perbandingan&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Metode</th><th>Kondisi</th><th>Biaya Estimasi</th><th>Kelebihan</th></tr></thead><tbody><tr><td>Linear Search (A1)</td><td>Semua kondisi</td><td><code>br + 1</code> seek</td><td>Tidak perlu indeks</td></tr><tr><td>Dengan Kunci</td><td>Seleksi pada kunci</td><td><code>br/2 + 1</code> seek</td><td>Hentikan saat cocok</td></tr></tbody></table><h3 id="contoh-soal-latihan-2" tabindex="-1">Contoh Soal Latihan <a class="header-anchor" href="#contoh-soal-latihan-2" aria-label="Permalink to &quot;Contoh Soal Latihan&quot;">​</a></h3><ol><li><strong>Studi Kasus</strong>: Sebuah relasi memiliki 50 blok, hitung biaya linear search jika seleksi pada kunci.<br><strong>Jawaban</strong>: <code>50/2 + 1 = 26</code> blok transfer + 1 seek.</li><li><strong>Studi Kasus</strong>: Mengapa pencarian biner tidak disarankan?<br><strong>Jawaban</strong>: Data tidak tersimpan berurutan, membutuhkan lebih banyak seek daripada indeks.</li><li><strong>Studi Kasus</strong>: Jika sebuah file tidak memiliki indeks, algoritma apa yang digunakan?<br><strong>Jawaban</strong>: Linear search (A1).</li></ol><h2 id="sorting" tabindex="-1">Sorting <a class="header-anchor" href="#sorting" aria-label="Permalink to &quot;Sorting&quot;">​</a></h2><ul><li><strong>Metode</strong>: <ul><li>Buat indeks untuk membaca relasi terurut, 1 blok akses per tuple</li><li>Gunakan quick-sort untuk relasi yang muat di memori</li><li>Gunakan external sort-merge untuk relasi besar</li></ul></li><li><strong>External Sort-Merge</strong><ul><li>Buat run terurut dengan memori M blok</li><li>Gabungkan run dengan N-way merge (N &lt; M)</li><li>Jika N ≥ M, butuh beberapa pass merge</li></ul></li><li><strong>Biaya</strong>: <ul><li>Transfer blok: <code>br (2 * [log(M/bb)-1 (br/M)] + 1)</code></li><li>Seek: <code>2 [br/M] + [br/bb] (2 [log(M/bb)-1 (br/M)] - 1)</code> (bb = blok per run)</li></ul></li></ul><h3 id="contoh-soal-latihan-3" tabindex="-1">Contoh Soal Latihan <a class="header-anchor" href="#contoh-soal-latihan-3" aria-label="Permalink to &quot;Contoh Soal Latihan&quot;">​</a></h3><ol><li><strong>Studi Kasus</strong>: Jika relasi 100 blok dengan memori 10 blok, hitung jumlah pass merge.<br><strong>Jawaban</strong>: <code>[log(10/1)-1 (100/10)] = 2</code> pass.</li><li><strong>Studi Kasus</strong>: Apa kelebihan external sort-merge?<br><strong>Jawaban</strong>: Cocok untuk relasi besar yang tidak muat di memori.</li><li><strong>Studi Kasus</strong>: Jika bb = 2 dan br = 50, hitung seek awal.<br><strong>Jawaban</strong>: <code>2 [50/10] = 10</code> seek.</li></ol><h2 id="join-operation" tabindex="-1">Join Operation <a class="header-anchor" href="#join-operation" aria-label="Permalink to &quot;Join Operation&quot;">​</a></h2><ul><li><strong>Algoritma</strong>: <ul><li>Nested-loop join: Uji setiap pasangan tuple, mahal tanpa indeks</li><li>Block nested-loop join: Gabungkan blok, lebih efisien</li><li>Indexed nested-loop join: Gunakan indeks pada atribut join</li><li>Merge-join: Gabungkan relasi terurut</li><li>Hash-join: Partisi dengan fungsi hash</li></ul></li><li><strong>Biaya</strong> (contoh: student 100 blok, takes 400 blok): <ul><li>Nested-loop: <code>nr * bs + br</code> (misal 2,000,100 blok)</li><li>Block nested-loop: <code>br * bs + br</code> (40,100 blok)</li><li>Indexed nested-loop: <code>br + nr * c</code> (25,100 blok)</li><li>Merge-join: <code>br + bs</code> + biaya sort</li><li>Hash-join: <code>3(br + bs)</code> (1500 blok)</li></ul></li></ul><h3 id="tabel-perbandingan-1" tabindex="-1">Tabel Perbandingan <a class="header-anchor" href="#tabel-perbandingan-1" aria-label="Permalink to &quot;Tabel Perbandingan&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Algoritma</th><th>Kondisi</th><th>Biaya Estimasi</th><th>Kelebihan</th></tr></thead><tbody><tr><td>Nested-Loop</td><td>Tanpa indeks</td><td><code>nr * bs + br</code></td><td>Fleksibel untuk kondisi</td></tr><tr><td>Block Nested-Loop</td><td>Dengan blok</td><td><code>br * bs + br</code></td><td>Efisien dengan memori</td></tr><tr><td>Indexed Nested-Loop</td><td>Ada indeks</td><td><code>br + nr * c</code></td><td>Cepat dengan indeks</td></tr><tr><td>Merge-Join</td><td>Relasi terurut</td><td><code>br + bs</code></td><td>Minim akses blok</td></tr><tr><td>Hash-Join</td><td>Equi-join</td><td><code>3(br + bs)</code></td><td>Efisien untuk partisi</td></tr></tbody></table><h3 id="contoh-soal-latihan-4" tabindex="-1">Contoh Soal Latihan <a class="header-anchor" href="#contoh-soal-latihan-4" aria-label="Permalink to &quot;Contoh Soal Latihan&quot;">​</a></h3><ol><li><strong>Studi Kasus</strong>: Hitung biaya nested-loop join untuk student (100 blok) dan takes (400 blok).<br><strong>Jawaban</strong>: <code>5000 * 400 + 100 = 2,000,100</code> blok.</li><li><strong>Studi Kasus</strong>: Kapan merge-join lebih baik daripada hash-join?<br><strong>Jawaban</strong>: Jika relasi sudah terurut, hindari biaya sort.</li><li><strong>Studi Kasus</strong>: Apa kelemahan hash-join?<br><strong>Jawaban</strong>: Rentan overflow jika partisi tidak merata.</li></ol><h2 id="evaluation-of-expressions" tabindex="-1">Evaluation of Expressions <a class="header-anchor" href="#evaluation-of-expressions" aria-label="Permalink to &quot;Evaluation of Expressions&quot;">​</a></h2><ul><li><strong>Materialization</strong><ul><li>Eksekusi operasi satu per satu, simpan hasil sementara ke disk</li><li>Biaya tambah karena tulis/baca disk</li></ul></li><li><strong>Pipelining</strong><ul><li>Proses operasi bersamaan, kirim tuple langsung ke operasi berikutnya</li><li>Lebih murah, tapi tidak cocok untuk sort atau hash-join</li><li>Tipe: demand-driven (lazy) atau producer-driven (eager)</li></ul></li></ul><h3 id="contoh-soal-latihan-5" tabindex="-1">Contoh Soal Latihan <a class="header-anchor" href="#contoh-soal-latihan-5" aria-label="Permalink to &quot;Contoh Soal Latihan&quot;">​</a></h3><ol><li><strong>Studi Kasus</strong>: Bandingkan materialization dan pipelining untuk query sederhana.<br><strong>Jawaban</strong>: Pipelining lebih cepat tanpa penyimpanan disk, materialization lebih lambat tapi selalu bisa digunakan.</li><li><strong>Studi Kasus</strong>: Kapan pipelining tidak efektif?<br><strong>Jawaban</strong>: Saat operasi seperti sort atau hash-join membutuhkan hasil lengkap.</li><li><strong>Studi Kasus</strong>: Jelaskan demand-driven pipelining.<br><strong>Jawaban</strong>: Operasi minta tuple dari anaknya saat dibutuhkan, simpan state untuk kelanjutan.</li></ol><h2 id="daftar-istilah-penting" tabindex="-1">Daftar Istilah Penting <a class="header-anchor" href="#daftar-istilah-penting" aria-label="Permalink to &quot;Daftar Istilah Penting&quot;">​</a></h2><ul><li><strong>Query Processing</strong>: Proses mengubah query menjadi hasil menggunakan parsing, optimasi, dan evaluasi</li><li><strong>Relational Algebra</strong>: Bahasa matematis untuk manipulasi data relasional</li><li><strong>Evaluation Plan</strong>: Rencana terperinci untuk mengevaluasi ekspresi relational algebra</li><li><strong>Query Optimization</strong>: Pemilihan rencana evaluasi dengan biaya terendah</li><li><strong>Disk I/O</strong>: Input/output disk yang menjadi faktor utama biaya query</li><li><strong>Seek</strong>: Waktu untuk memindahkan head disk ke lokasi data</li><li><strong>Block Transfer</strong>: Waktu untuk membaca atau menulis satu blok data</li><li><strong>Nested-Loop Join</strong>: Algoritma join dengan pengulangan tuple</li><li><strong>Merge-Join</strong>: Algoritma join untuk relasi terurut</li><li><strong>Hash-Join</strong>: Algoritma join dengan partisi hash</li><li><strong>Materialization</strong>: Penyimpanan sementara hasil operasi ke disk</li><li><strong>Pipelining</strong>: Pengiriman tuple langsung ke operasi berikutnya</li></ul><h2 id="glossarium" tabindex="-1">Glossarium <a class="header-anchor" href="#glossarium" aria-label="Permalink to &quot;Glossarium&quot;">​</a></h2><ul><li><strong>tT</strong>: Waktu transfer satu blok</li><li><strong>tS</strong>: Waktu untuk satu seek</li><li><strong>br</strong>: Jumlah blok relasi r</li><li><strong>bs</strong>: Jumlah blok relasi s</li><li><strong>nr</strong>: Jumlah record relasi r</li></ul>',33)])])}const h=i(s,[["render",r]]);export{k as __pageData,h as default};
