import{_ as n,c as i,o as t,ae as e}from"./chunks/framework.BlRNOFgT.js";const m=JSON.parse('{"title":"Rangkuman Materi IF3140 – Sistem Basis Data: Query Optimization","description":"","frontmatter":{},"headers":[],"relativePath":"system-database/query-optimization.md","filePath":"system-database/query-optimization.md"}'),s={name:"system-database/query-optimization.md"};function r(l,a,o,u,g,k){return t(),i("div",null,[...a[0]||(a[0]=[e('<h1 id="rangkuman-materi-if3140-–-sistem-basis-data-query-optimization" tabindex="-1">Rangkuman Materi IF3140 – Sistem Basis Data: Query Optimization <a class="header-anchor" href="#rangkuman-materi-if3140-–-sistem-basis-data-query-optimization" aria-label="Permalink to &quot;Rangkuman Materi IF3140 – Sistem Basis Data: Query Optimization&quot;">​</a></h1><h2 id="langkah-dasar-pemrosesan-query" tabindex="-1">Langkah Dasar Pemrosesan Query <a class="header-anchor" href="#langkah-dasar-pemrosesan-query" aria-label="Permalink to &quot;Langkah Dasar Pemrosesan Query&quot;">​</a></h2><ul><li><strong>Parsing dan translasi</strong></li><li><strong>Optimasi</strong></li><li><strong>Evaluasi</strong></li></ul><h2 id="pengenalan" tabindex="-1">Pengenalan <a class="header-anchor" href="#pengenalan" aria-label="Permalink to &quot;Pengenalan&quot;">​</a></h2><ul><li><strong>Cara alternatif mengevaluasi query tertentu</strong></li><li><strong>Ekspresi ekuivalen</strong></li><li><strong>Algoritma berbeda untuk setiap operasi</strong></li></ul><h3 id="pengenalan-lanjutan" tabindex="-1">Pengenalan (Lanjutan) <a class="header-anchor" href="#pengenalan-lanjutan" aria-label="Permalink to &quot;Pengenalan (Lanjutan)&quot;">​</a></h3><ul><li><strong>Rencana evaluasi menentukan algoritma apa yang digunakan untuk setiap operasi dan bagaimana eksekusi operasi dikoordinasikan</strong></li><li><strong>Cari tahu cara melihat rencana eksekusi query di database favorit Anda</strong></li><li><strong>Perbedaan biaya antara rencana evaluasi bisa sangat besar</strong> (contoh: detik vs hari)</li><li><strong>Langkah optimasi berbasis biaya:</strong><ul><li><strong>Hasilkan ekspresi ekuivalen secara logis menggunakan aturan ekuivalensi</strong></li><li><strong>Anotasi ekspresi hasil untuk mendapatkan rencana query alternatif</strong></li><li><strong>Pilih rencana termurah berdasarkan biaya perkiraan</strong></li></ul></li><li><strong>Estimasi biaya rencana berdasarkan:</strong><ul><li><strong>Informasi statistik tentang relasi</strong> (contoh: jumlah tuple, jumlah nilai berbeda untuk atribut)</li><li><strong>Estimasi statistik untuk hasil menengah</strong> (untuk menghitung biaya ekspresi kompleks)</li><li><strong>Rumus biaya untuk algoritma</strong>, dihitung menggunakan statistik</li></ul></li></ul><h2 id="transformasi-ekspresi-relasional" tabindex="-1">Transformasi Ekspresi Relasional <a class="header-anchor" href="#transformasi-ekspresi-relasional" aria-label="Permalink to &quot;Transformasi Ekspresi Relasional&quot;">​</a></h2><ul><li><strong>Dua ekspresi aljabar relasional ekuivalen jika menghasilkan set tuple yang sama pada setiap instance database legal</strong><ul><li><strong>Urutan tuple tidak relevan</strong></li><li><strong>Tidak peduli jika hasil berbeda pada database yang melanggar batasan integritas</strong></li></ul></li><li><strong>Dalam SQL, input dan output adalah multiset tuple</strong><ul><li><strong>Dua ekspresi ekuivalen jika menghasilkan multiset tuple yang sama pada setiap instance database legal</strong></li></ul></li><li><strong>Aturan ekuivalensi menyatakan bahwa ekspresi dua bentuk ekuivalen</strong><ul><li><strong>Dapat mengganti ekspresi bentuk pertama dengan kedua, atau sebaliknya</strong></li></ul></li></ul><h3 id="aturan-ekuivalensi" tabindex="-1">Aturan Ekuivalensi <a class="header-anchor" href="#aturan-ekuivalensi" aria-label="Permalink to &quot;Aturan Ekuivalensi&quot;">​</a></h3><ul><li><strong>Operasi seleksi konjungtif dapat diuraikan menjadi urutan seleksi individu:</strong> σθ1∧θ2(E) = σθ1(σθ2(E))</li><li><strong>Operasi seleksi bersifat komutatif:</strong> σθ1(σθ2(E)) = σθ2(σθ1(E))</li><li><strong>Hanya proyeksi terakhir dalam urutan yang diperlukan, yang lain bisa dihilangkan:</strong> ΠL1(ΠL2(…ΠLn(E))) = ΠL1(E)</li><li><strong>Seleksi dapat digabungkan dengan produk Cartesian dan join theta:</strong><ul><li><strong>σθ(E1 × E2) = E1 ⋈θ E2</strong></li><li><strong>σθ1(E1 ⋈θ2 E2) = E1 ⋈θ1∧θ2 E2</strong></li></ul></li><li><strong>Operasi theta-join (dan natural join) bersifat komutatif:</strong> E1 ⋈θ E2 = E2 ⋈θ E1</li><li><strong>(a) Operasi natural join bersifat asosiatif:</strong> (E1 ⋈ E2) ⋈ E3 = E1 ⋈ (E2 ⋈ E3) <ul><li><strong>(b) Theta join asosiatif dengan cara berikut:</strong> (E1 ⋈θ1 E2) ⋈θ2∧θ3 E3 = E1 ⋈θ1∧θ3 (E2 ⋈θ2 E3) (di mana θ2 hanya melibatkan atribut dari E2 dan E3)</li></ul></li></ul><h3 id="tabel-perbandingan-komutatif-vs-asosiatif" tabindex="-1">Tabel Perbandingan: Komutatif vs Asosiatif <a class="header-anchor" href="#tabel-perbandingan-komutatif-vs-asosiatif" aria-label="Permalink to &quot;Tabel Perbandingan: Komutatif vs Asosiatif&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Konsep</th><th>Penjelasan</th></tr></thead><tbody><tr><td>Komutatif</td><td>Urutan operasi tidak memengaruhi hasil (E1 ⋈θ E2 = E2 ⋈θ E1)</td></tr><tr><td>Asosiatif</td><td>Pengelompokan operasi tidak memengaruhi hasil ((E1 ⋈ E2) ⋈ E3 = E1 ⋈ (E2 ⋈ E3))</td></tr></tbody></table><h2 id="contoh-soal-latihan" tabindex="-1">Contoh Soal Latihan <a class="header-anchor" href="#contoh-soal-latihan" aria-label="Permalink to &quot;Contoh Soal Latihan&quot;">​</a></h2><ol><li><strong>Soal:</strong> Diberikan ekspresi σdept_name=&#39;Music&#39;(instructor ⋈ teaches ⋈ course), ubah menjadi bentuk ekuivalen menggunakan aturan seleksi dan join. <ul><li><strong>Jawaban:</strong> instructor ⋈ teaches ⋈ σdept_name=&#39;Music&#39;(course)</li></ul></li><li><strong>Soal:</strong> Jika ada ekspresi Πname, title(σyear=2009(instructor ⋈ teaches ⋈ course)), apakah proyeksi berulang diperlukan? Jelaskan. <ul><li><strong>Jawaban:</strong> Tidak, hanya proyeksi terakhir (Πname, title) yang diperlukan, sisanya bisa dihilangkan sesuai aturan ekuivalensi.</li></ul></li><li><strong>Soal:</strong> Tentukan apakah (E1 ⋈θ1 E2) ⋈θ2 E3 ekuivalen dengan E1 ⋈θ1 (E2 ⋈θ2 E3) jika θ2 melibatkan atribut dari E1, E2, dan E3. <ul><li><strong>Jawaban:</strong> Tidak ekuivalen, karena θ2 harus hanya melibatkan atribut dari E2 dan E3 untuk asosiatifitas.</li></ul></li></ol><h2 id="daftar-istilah-penting" tabindex="-1">Daftar Istilah Penting <a class="header-anchor" href="#daftar-istilah-penting" aria-label="Permalink to &quot;Daftar Istilah Penting&quot;">​</a></h2><ul><li><strong>Query Optimization:</strong> Proses menemukan rencana evaluasi dengan biaya terendah untuk menjalankan query.</li><li><strong>Evaluation Plan:</strong> Rencana yang menentukan algoritma dan koordinasi eksekusi operasi dalam query.</li><li><strong>Equivalence Rules:</strong> Aturan yang memungkinkan transformasi ekspresi relasional menjadi bentuk ekuivalen.</li><li><strong>Cost-based Optimization:</strong> Pendekatan optimasi yang memilih rencana berdasarkan estimasi biaya.</li><li><strong>Relational Algebra:</strong> Sistem aljabar untuk memanipulasi data relasional dengan operasi seperti seleksi dan join.</li><li><strong>Theta-join:</strong> Jenis join yang menggunakan kondisi theta untuk menggabungkan relasi.</li><li><strong>Natural Join:</strong> Join yang menggabungkan relasi berdasarkan atribut yang sama tanpa kondisi tambahan.</li></ul><h2 id="glossarium" tabindex="-1">Glossarium <a class="header-anchor" href="#glossarium" aria-label="Permalink to &quot;Glossarium&quot;">​</a></h2><ul><li>SQL: Structured Query Language</li></ul>',19)])])}const h=n(s,[["render",r]]);export{m as __pageData,h as default};
